# const
## 只读变量
C++定义了一套完整的只读量定义方法,被`const`修饰的变量都是只读量,编译器会在编译期进行冲突检查,避免对只读量的修改,同时可能会执行一些优化.
`const`关键字意味着**只读**.

## 常量指针与常量引用
`const`关键字修饰其后的第一个元素.
```cpp
const int a = 50; // const修饰关键字int
int const b = 10; // const修饰变量b
```
第一行指定该`int`变量只读,第二句指定变量`b`只读,所以两种写法是等价的.
```cpp
int a;
const int *p = &a; // const修饰关键字int
int const *p = &a; // const修饰int型变量*p
int * const p = &a // const修饰指针变量p
const int * const p = &a; // const同时修饰关键字int和指针变量p
```
根据修饰规则: 第一,二句不能修改`*p`所指向的`int`值,但能修改指针`p`的值.第三句不能修改指针`p`的值但可以修改解引用后`*p`的值.第四句即不能修改指针的值也不能修改指针所指向的值.

## 常量参数
在函数参数里使用`const`限定参数类型,可以避免变量被错误地修改,同时增加代码可读性.
```cpp
void f(const vector<int> &a, int &b) {
	// a中任意元素的值都不能被修改, b的值可以被修改
}
```

## const成员函数
在成员函数的参数列表后添加`const`关键字,表明该函数不会修改类的**非静态成员**,`const`实际是修饰隐藏的`this`指针.
```cpp
struct node {
	int a = 10; // 成员
	void f() const;
	void g(int v) const {
		a = v; // 修改了成员a的值
	}
} t;

void node::f() const {
	cout << "const" << endl;
}

int main() {
	t.f();
	t.g(-10); // 会报错
}
```
1. `const`对象**只能调用`const`函数**,普通对象优先调用普通成员函数.
2. `cosnt`成员函数只能调用`const`成员函数(防止间接修改成员值).
3. `const`成员函数可与非`const`版本构成重载,编译器根据对象常量性选择调用.
```cpp
struct node {
	int f(int a, int b) const {return a + b;}
	int f(int a, int b) {return a - b;}
	int g(int a, int b) const {return f(a, b);} // const函数只能调用const函数
};
const node t; // const对象
node s;
int main() {
	cout << t.f(1, 2) << endl; // 结果为3
	cout << s.f(2, 3) << endl; // 结果为-1
}
```

## 常量表达式constexpr (C++11)
常量表达式是指编译时能计算出结果的表达式,`constexpr`要求编译器在**编译时**就能求得函数或变量的值.
编译时计算能允许更好的优化,比如将结果硬编码到汇编中,消除运行时计算开销.
```cpp
constexpr int f(int x) {
	return x << 1;
}

constexpr int t = f(x); // constexpr常量初始化的值只能为常值或constexpr函数值
```
