# 指针
## 指针是什么
在程序中,我们的数据都有其存储的地址,即变量在**物理内存**中的存储位置.存放地址所用的变量类型有一个特殊的名字,叫做指针变量,简称指针.
>在$32$位机上地址用$32$位二进制整数表示,所以一个指针大小为$4$字节.在$64$位机上地址用$64$位二进制整数表示,所以一个指针大小为**$8$字节**.

为了针对不同类型的数据,指针变量也有不同的类型,比如,由于一个`int`类型的变量占据$32$位空间,所以其指针变量对应一块大小为$4$字节的空间的**起始位置**.一个`char`类型的指针变量对应一块$1$字节的空间的**起始位置**.而下面的结构体指针`p`对应一块$13$字节空间的**起始位置**.
```cpp
struct node {
	int a; // 4字节
	long long b; // 8字节
	char c; // 1字节
};
node *p;
```
C/C++中,指针变量的定义需要在类型名后加上一个星号`*`.比如,`int`类型的指针变量的定义即为`int *`.
注意,无论指针对应多大的空间(指针类型是什么),指针的大小都为**$8$字节**($64$位下).

## 变量与地址
我们来看以下赋值代码:
```cpp
int a, b;
a = 10;
b = a / 10;
```
从内存层面来说,`a = 10`实际上是将变量`a`所对应空间(`a`的地址及其后总共$4$字节的连续空间)的值修改为`10`,`b = a / 10`实际上是先计算`a / 10`的值得到`1`,再将`b`所对应空间的值修改为`1`.
如果我们想直接获取变量的地址应该怎么办?可以使用`&`符号.
```cpp
int a;
int *p = &a;
cout << &a << " " << p << endl; // 每次运行都由程序随机分配
```
>输出
>0xecfc3ffbac 0xecfc3ffbac

那我们又如何通过变量的地址来修改变量的值呢?
## 指针的使用
要想访问指针所**指向**的空间,需要对指针变量进行**解引用**(dereference),使用`*`符号.
通过变量地址和指针类型,指针解引用后的结果等价于存储在这段内存上的变量,如下例通过修改`*b`来改变`a`的值
```cpp
int a = 10;
cout << a << endl;
int *b = &a; // 此处*号为指针变量的定义
*b = 20; // 此处*号为解引用
cout << a << " " << *b << endl; // 此处*号为解引用
```
>输出
>10
>20 20

对结构体指针也是类似.如果要访问指针指向的结构中的成员,需要先对指针进行解引用,再使用`.`成员关系运算符.不过,更推荐使用**箭头运算符**`->`这一更简便的写法.
```cpp
struct ThreeInt {
	int a, b, c;
};
int main() {
	ThreeInt x{1, 2, 3}, y{6, 7, 8};
	ThreeInt *px = &x;
	(*px) = y; // 此时x为{6,7,8}
	(*px).a = 4; // 此时x为{4,7,8}
	px->b = 5; // 此时x为{4,5,8}
}
```

## 指针的偏移
指针变量也可以和**整数**进行加减操作.任何类型的指针每加$1$,其指向的地址将偏移**指针类型**所对应的空间大小.对于`int`型指针,每加$1$(递增$1$),其指向的地址偏移$32$位(即$4$个字节).
### 使用指针偏移访问数组
我们前面说过,数组是一块连续的存储空间.而在C/C++中,直接使用数组名,得到的是数组的起始地址.
```cpp
int main() {
	int a[3] = {1, 2, 3};
	int* p = a; // p指向a[0]
	cout << p << endl; // 输出地址
	*p = 4; // 此时a[]为[4, 2, 3]
	p = p + 1;   // p指向a[1]
	*p = 5; // 此时a[]为[4, 5, 3]
	p++; //p指向a[2]
	*p = 6; // 此时a[]为[4, 5, 6]
	for (int i = 0; i < 3; i++) cout << a[i] << " ";
}
```
>输出
>0x99fadffda0
>4 5 6

我们常用`[]`运算符来访问数组中某一指定偏移量处的元素.比如`a[3]`或者`p[4]`.这种写法和对指针进行运算后再引用是等价的,即`p[4]`和`*(p + 4)`是等价的两种写法.
## 空指针
在C++11之前,C++和C一样使用`NULL`宏表示空指针常量,C++中`NULL`的实现一般如下:
```cpp
#define NULL 0
```
但是这会引发许多问题,而为了解决这些问题,C++11引入了`nullptr`关键字作为空指针常量.
C++规定`nullptr`可以隐式转换为任何指针类型,这种转换结果是该类型的空指针值.
`nullptr`的类型为`std::nullptr_t`,称作空指针类型,`NULL`宏的实现也被修改为了:
```cpp
#define NULL nullptr
```

## 指针的进阶使用
### 指针类型参数的使用
在C/C++中,调用函数时使用的参数,均以拷贝的形式传入子过程中(引用除外，会在后续介绍).但是,如果某个函数希望**修改外部数据**,或者某个结构体/类的**数据量较为庞大**,不宜拷贝,这时,则可以通过向其传入外部数据的地址,便得以在其中访问甚至修改外部数据.
```cpp
void my_swap(int *a, int *b) { // 存放地址的变量类型为指针
	int t = *a; // 要想获取指针对应空间的值需要解引用
	*a = *b;
	*b = t;
}

int main() {
	int a = 1, b = 2;
	my_swap(&a, &b); // 传入的值的类型为地址
}
```

### 动态内存分配
程序编写时往往会涉及到动态内存分配,即程序会在运行时,向操作系统动态地申请或归还存放数据所需的内存.要使用一块空间,我们需要将这块空间的地址存储在指针变量中.
在C++中,我们使用`new`运算符来获取一块内存,使用`delete`运算符释放某指针所指向的空间.
```cpp
int *p = new int(1234);
cout << *p << endl;
delete p;
```
`new`表达式将尝试开辟一块对应大小的空间,并尝试在这块空间上构造这一对象,并返回这一空间的**地址**.`delete`表达式将释放指针所对应的空间.
>`delete`不能对一块内存释放两次或以上,但对空指针`nullptr`多次使用`delete`操作是合法的.

`new`不仅可用来定义新变量,也可以用来开辟新的对象:
```cpp
struct TreeInt {
	int a, b, c;
};

int main() {
	TreeInt *p = new TreeInt{1, 2, 3};
	cout << p->a << " " << (*p).b << endl;
	delete p;
}
```

### 动态创建一维数组
可以使用`new[]`运算符创建数组,这时`new[]`运算符会返回数组的**首地址**,也就是数组第一个元素的地址.释放时,则需要使用`delete[]`运算符.
```cpp
int *p = new int[5]; // 开辟变量类型为int的5 * 4字节的连续空间并返回空间的首地址
*(p + 2) = 3; // 由于p是int类型指针所以*(p + 2)等价于int数组的p[2]
delete[] p;
```
数组中元素的存储是连续的,即`p + 1`指向的是`p`的后继元素.

### 动态创建二维数组
在存放矩阵形式的数据时,可能会用到二维数组这样的数据类型.从语义上来讲,二维数组是一个**数组的数组**.而计算机内存可以视作一个很长的一维数组,要在计算机内存中存放一个二维数组,便有连续与否的说法.
所谓连续,即二维数组的任意一行的末尾与下一行的起始,在物理地址上是毗邻的.
1. 我们可以使用类似下面这样的语句静态声明一个$N$行$M$列的二维数组(数组的行列初始下标都为$0$)，其空间在物理上是连续的:
```cpp
int a[N][M];
```
>对于数组`a[N][M]`,其第$i$行的第一个元素所对地址为`a[i]`或者`&a[i][0]`(可将`a[i]`看作一个整体),那么`a[i][j]`可以由`*(a[i] + j)`解引用得到.

2. 但实际使用中,二维数组的大小可能不是固定的,需要动态内存分配.常见的方式是声明一个长度为$N\times M$的**一维数组**,并通过下标`r * M + c`访问二维数组中下标为`(r, c)`的元素.这种方法可以保证二维数组是**连续的**.
```cpp
int r = 2, c = 5, N = 10, M = 10;
int *a = new int[N * M];
cout << (a[r * M + c] = 10) << endl; // 第二行第五列的元素
```
3. 此外,亦可以根据数组的数组这一概念来进行内存的获取与使用.由于一个一维数组的任一元素`a[k]`实际上能由数组的第一个元素的地址`a`的解引用`*(a + k)`得到,即一个一维数组等价于该变量类型下的一个指针,那么一个存放若干数组的数组,实际上为一个存放的若干数组的首地址的数组,也就是一个存放若干指针变量的数组.

这个存放若干指针变量的数组,又等价于一个**变量类型为指针**的指针.而我们知道,`T *p`用于定义变量类型为`T`的指针,此处`T`又等于`type *`,那么这个指向指针的指针的定义方法就是`type **p`,也叫做**二重指针**:
```cpp
int **a = new int*[5]; // 开辟变量类型为int *的5个连续空间
```
接着，我们需要为每一个二级指针对应的数组申请空间:
```cpp
for (int i = 0; i < 5; i++) a[i] = new int[5];
```
至此,我们便完成了内存的获取.而对于这样获得的内存的释放,则需要进行一个逆向的操作: 即先释放每一个数组,再释放存储这些数组首地址的数组,如:
```cpp
for (int i = 0; i < 5; i++) 
	delete[] a[i];
delete[] a;
```
需要注意,这样获得的二维数组,不能保证其空间是连续的.

4. 还有一种方式,需要使用到**指向数组的指针**.

我们之前说到,在C/C++中,直接使用数组名,值等于数组首元素的地址,但是数组名表示的这一变量的类型实际上并不一定是单个元素.
```cpp
int a[5] = {1, 2, 3, 4, 5};
int b[3][2] = {{1, 2}, {3, 4}, {5, 6}};
```
> 上述代码中,`*(a + 1)`等价于`a[1]`,即`a`每增加$1$,地址偏移$4$字节,此时`a`的类型为`int *`.
> `*(b + 1)`等价于`b[1][0]`,与`*b`即`b[0][0]`之间还隔着`b[0][1]`,即$8$个字节.
> `b`的类型实际上为`int (*)[2]`,可理解为数组`int[2]`的指针,`b`每增加$1$地址会偏移`int[2]`的大小.

我们利用指向数组的指针可以获得内存连续的数组:
```cpp
int main() {
	int (*a)[5] = int[4][5]; // 定义int[5]的指针并开辟int[4][5]的连续空间
	int *p = a[2];
	*(p + 1) = 10; // *p等价于a[2][0]
	// p是int类型的指针,p + 1偏移四字节所以*(p + 1)等价于a[2][1]
	*(*(a + 1) + 3) = -10; // a是数组int[5]类型的指针,*(a + 1)等价于a[1](偏移20字节)
	// a[1]是int类型的指针, *(a[1] + 3)等价于a[1][3],所以原表达式等价于a[1][3]
}
```
5. 上述数组的定义方式,只要内存连续,就可以用`a[r][c]`直接访问位于`(r, c)`的元素.

## 指针与函数 (待完成)
### 指向函数的指针

# 引用 (待完成)