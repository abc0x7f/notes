# 最小生成树 Minimum spanning tree (MST)
## 定义
从n个点的带边权图中选出n-1条边连接所有n个点,求边权之和最小的方案.
## prim算法
### 算法思想
`prim`算法的主要思想是从任意一个顶点开始,每次选择一个与当前连通块相邻的权值最小的边,并将其加入到最小生成树的边集合中,直到所有顶点都被加入到最小生成树中.
### 证明
假设最终的最小生成树为$G$.
某一时刻点$b$是到联通块距离最小的点,即存在连通块里的点$a$使得边$ab$为所有**一个点在连通块里而另一个点不在**的边中权值最小的边.若边$ab$在$G$中,则算法成立;否则将边$ab$加入$G$形成一个带环图,则$a$必定同时与$b$和另一个不在连通块中的点$c$相连,且$w_{ab}\leq w_{ac}$.若$w_{ab}<w_{ac}$,删除边$ac$所形成的新的生成树的总权值小于G,矛盾.若$w_{ab}=w_{ac}$,则两者都是最小生成树.
### 代码
prim算法适用于稠密图,复杂度为$O(n^2)$.
```cpp
int cur = 1, ans = 0; // cur为最新加入连通块的点
for (int t = 1; t < n; t++) {
	int k = 1;
	im = 1e15; f[cur] = 1;
	for (int i = 1; i <= n; i++)
		chkmin(dis[i], w[i][j]); // dis[i]是点i到连通块的距离,初始值为inf
	for (int i = 1; i <= n; i++)
		if (!f[i] && chkmin(im, dis[i])) k = i;
	ans += dis[k];
	cur = k;
}
```
## kruskal算法
### 算法思想
`kruskal`算法的主要思想是按照边权值从小到大依次选择边,如果这条边的两个端点不在同一个连通块中,就把这条边加入到最小生成树的边集合中.
### 证明
假设`kruskal`生成树为$G$,最小生成树为$T$,在$G$中且不在$T$中的权值最小的边为$e$.将$e$加入$T$中形成环形图,再从环上删除某条不在$G$中的边$f$,得到新的树$T'$.
若$w_e<w_f$,$T'$的总权值比$T$小,与$T$为最小生成树矛盾.若$w_e>w_f$,则`kruskal`生成树$G$在加入$e$之前必定考虑过$f$(**从小到大**),没有加入$f$的原因是$f$的两端点**已经联通**.
而根据$e$的定义,$G$中权值比$e$小的边一定都在$T$中,这说明$T$在$f$的两端点已经联通的情况下依然加入了$f$,形成了环,矛盾.
所以只能有$w_e=w_f$,$T'$依然是最小生成树的情况下和$G$相同的边多了一条,归纳法可证算法正确.
### 代码
```cpp
struct node {
	int u, v, w;
	bool operator < (const node& A) {
		return w < A.w;
	}
} e[M];

int n, m, ans, fa[N], cnt = 1;

int find_f(int x){
	return x == fa[x] ? x : fa[x] = find(fa[x]);
}

int main() {
	for (int i = 1; i <= m; i++)
		cin >> e[i].u >> e[i].v >> e[i].w;
	sort(e + 1, e + m + 1);
	for (int i = 1; i < n; i++) {
		for (; find_f(e[cnt].u) == find_f(e[cnt].v); cnt++);
		fa[find_f(e[cnt].u)] = e[cnt].v;
		ans += e[cnt].w;
		cnt--;
	}
	cout << ans << endl;
}
```
## 简单题
[P1265 公路修建 - 洛谷](https://www.luogu.com.cn/problem/P1265)
[P4047 [JSOI2010] 部落划分 - 洛谷](https://www.luogu.com.cn/problem/P4047)
## 参考文章
[【最小生成树】学习笔记 - 洛谷专栏](https://www.luogu.com.cn/article/ve4y2g2n)
[prim和kruskal算法的正确性证明（贪心、最优子结构）_证明prim算法的正确性-CSDN博客](https://blog.csdn.net/weixin_44083819/article/details/129840549)
