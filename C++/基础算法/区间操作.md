# 树状数组
## lowbit
`lowbit(x)`用于计算`x`二进制下最低位的$1$的实际值.`-x`在二进制下是`x`的反码加$1$,所以`x & -x`就能计算出答案(例如`x`为`0110`则`-x`为`1001 + 1 = 1010`).
```cpp
inline int lowbit(int x) {
	return x & -x;
}
```

## 求前缀和
假设`x = 010011`,我们将`x`不断加上`lowbit(x)`依次得到`010100`,`011000`,`100000`.由此可以发现,所有$i\in[x - lowbit(x) + 1, x]$不断加上`lowbit(i)`最终都可以获得`x`.
反之若我们令`tr[x]`包含所有$a_i,i\in[x-lowbit(x)+1,x]$的值,那么`tr[x' = x - lowbit(x)]`又将包含$a_i,i\in[x'-lowbit(x')+1,x']$的值.`x`不断地减去`lowbit(x)`,将所有的值相加就可以获得$\sum_{i=1}^na_i$.
```cpp
const int M = 100500;
int tr[M], x, v, y;

void add(int x, int v) {
	for (; x <= M - 1; x += lowbit(x)) // M - 1为可能的最大值
		tr[x] += v;
	return ;
}

int sum(int x) {
	int ans = 0;
	for (; x; x -= lowbit(x))
		ans += tr[x];
	return ans;
}

int main() {
	cin >> x >> v >> y;
	add(x, v); // a[x]加上v
	cout << sum(y) << endl; // a[1]~a[y]的和
}
```

## 其他技巧 (待完成)
1. 差分数组: 区间修改,单点求和.
2. 树状数组求逆序对.
