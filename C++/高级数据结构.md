# 结构体
结构体可以看做是一系列称为成员元素的组合体,它们储存在**连续的**内存空间上.
```cpp
const int array_length = 10;
struct Object {
	int weight;
	int value;
} e[array_length];

Object b, B[array_length], tmp;
Object *c;
```
如果是定义内置类型的指针,则与平常定义指针一样.
```cpp
struct Edge {
	Edge *nxt;
};
```
可以使用`变量名.成员元素名`访问结构体内成员.例如可以使用`cout << var.v`来输出`var`的`v`成员.

也可以使用`指针名->成员元素名`或者使用`(*指针名).成员元素名`进行访问.例如使用`(*ptr).v = tmp`或者`ptr->v = tmp`可以将结构体指针`ptr`指向的结构体的成员元素`v`赋值为`tmp`.
## 初始化方法
1. 声明时初始化(效率最高但初值相同):
```cpp
struct node {
	int weight = 1, value = 0;
};
```
2. 赋值初始化(效率低,先调用默认构造函数,再调用赋值构造函数):
```cpp
struct node {
	int weight, value;
	node(int w, int v) {weight = w; value = v;}
} a(1, 0);
```
2.  初始化列表(效率高,直接调用拷贝构造函数):
```cpp
struct node {
	int weight, value;
	node(int weight, int value) : weight(weight), value(value) {}
} a(1, 0);
```
2. 

## 常量结构体 (待完成)
使用`const`关键字修饰结构体时,必须使用`()`或`{}`或构造函数初始化结构体.此时结构体内任何成员都不可修改.同时成员函数必须为或者可重载为`const`成员函数.
```cpp
struct Object1 {
	int weight, value;
	int f() {cout << "Object1" << endl;}
	int f() const {cout << "const Object1" << endl;} // 可重载为const成员函数
};

struct Object2 {
	int x, y;
	Object2() {x = 0, y = 0;}	
};
const Object1 a {1, 2};
const Object2 b;
```
以下为以`constexpr`关键字修饰结构体时的用法.
```cpp
struct point {
	int x, y;
    constexpr point(int u, int v) : x(u), y(v) {}
    constexpr int area() const {return x * y;}
};
 
int main() {
    constexpr point a(5, 4); // 或者a = {5, 4}
	constexpr int S1 = a.area();
    return 0;
}
```

# 类
类`class`是结构体的拓展,不仅能够拥有成员元素,还拥有成员函数.不过C++中`struct`关键字定义的也是类.
类似`struct`,可以使用`.`符号或`->`符号(对于类指针)访问成员.
```cpp
class Object {
	public:
		int weight;
		int value;
} e[10];

Object b, B[10];
Object *c;
```
`public`属于访问说明符:
1. `public`: 该访问说明符之后的各个成员都可以被公开访问,(无论类内还是类外).
2. `protected`: 该访问说明符之后的各个成员可以被类内,**派生类**或者**友元**的成员访问,但类外不能访问.
3. `private`: 该访问说明符之后的各个成员只能被类内成员或者**友元**的成员访问,不能被从类外或者派生类中访问.

对于`struct`,它的所有成员都是默认`public`.对于`class`,它的所有成员都是默认`private`.

## 友元与派生类
1. 友元: 使用`friend`关键字修饰某个函数或者类.可以使得被修饰者在**不成为成员函数或者成员类**的情况下,访问该类的私有`private`或者受保护`protected`成员.
2. 派生类`derived class`: C++允许使用一个类作为**基类**,并通过基类派生出**派生类**.其中派生类可继承基类中的成员变量和成员函数,以提高代码的复用率.派生类可以访问基类的`public`和`protected`的元素,但不能访问`private`元素.

## 成员函数
```cpp
class Object {
	public:
		int weight, value;
		void print() {cout << weight << endl;}
		void change_w(int w); 
};

void Object::change_w(int w) {weight = w;}
Object var;
// var.change_w(10); 调用成员函数
```

## 重载运算符(待完成)

## 构造函数
为了在定义类时设定初始值,需要定义**构造函数**.
```cpp
class Object {
	public:
		int weight, value;
		Object() {weight = 0, value = 0;} // 默认构造函数
		Object(int u, int v) {weight = u, value = v;} // 可以重载构造函数
};
```
或者:
```cpp
class Object {
	public:
		int weight, value;
		Object(); // 先声明
}

Object::Object() {weight = 0, value = 0;}
```
初始化类的方法如下:
```cpp
/* 未定义构造函数时 */
Object a = {1, 1};
Object b {1, 1};
/* 定义无参数(默认)构造函数后 */
Object a;
a = Object(); // 显式调用默认构造函数
/* 定义含参构造函数后 */
Object a = {1, 1};
Object b {1, 1};
Object c(1, 1);
b = Object(1, 1); // 显式调用构造函数
```
`()`只是调用了复制构造函数,而`{}`在调用复制构造函数前会调用默认构造函数.
默认情况下,进行的赋值都是对应元素间进行**浅拷贝**,如果成员元素中有指针,则在赋值完成后,两个变量的成员指针具有相同的地址.

## 隐式类型转换(待完成)
```cpp
class Node {
	public:
		int var;
		Node(int _var) : var(_var) {} // ?
};
Node a = 1; // ?
```
在构造函数前追加`explicit`关键字.这会告诉编译器必须显式进行调用.

## 析构函数
对于已经指向了**动态申请**(`new`)的内存的指针来说,该指针在销毁时不会自动释放所指向的内存,需要手动释放动态内存.如果结构体的成员元素包含指针,同样会遇到这种问题.
此时需要用到析构函数,**析构**函数将会在该变量被销毁时被自动调用,重载的方法形同构造函数,但需要在前加`~`.
```cpp
class Object {
	public:
		int *ned;
	~Object() {delete ned;}
};
```

# 联合体
**联合体**是特殊的类类型,它在一个时刻只能保有其一个非静态数据成员.
```cpp
union MyUnion {
	int x;
	long long y;
} t;
```
联合体所有成员**共用内存空间与地址**,其所占用的内存空间大小**不小于**其最大的成员的大小.上述代码中变量`x`和`y`共用一段内存,且`x`的存储区域真包含于`y`所处的内存区域中.也就是说如果改变`x`的值(`x`,`y`共用区域),`y`所对应区域的值也会改变.