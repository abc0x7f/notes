# 定义
对于程序设计中重复的过程(代码片段),我们希望能将其组织成**可复用的模块**,以提高代码的可读性和可维护性,由此就引入了函数.函数一般是若干语句的集合,其基本结构如下:
```cpp
返回类型 函数名(参数列表) {
	函数体;
}
```
1. 返回类型: 函数执行后返回的数据类型,如果函数不返回任何值,使用`void`.
2. 函数名: 函数的名称,用于调用函数.
3. 参数列表: 函数接受的参数,可以为空.
4. 函数体: 函数的具体实现(非`void`类型函数要包含返回值的过程).

如果函数不需要参数,则可以将参数列表置空.如果函数不需要有返回值,则将函数的返回值类型标为`void`.有返回值的函数执行到`return 值;`语句会**直接结束**当前函数并返回对应值.无返回值的函数执行到`return;`语句也会结束执行.

函数可以在声明后定义,也可以在声明时定义.声明通常放在头文件中,定义放在源文件.
```cpp
int mul(int a, int b) {return a * b;} // 声明时定义

int add(int a, int b); // 声明方式1
int add(int, int); // 声明方式2

int add(int a, int b) { // 声明后实现
	return a + b;
}
```

# 调用
函数调用时,需要提供与参数列表匹配的参数.
```cpp
int result = add(3, 5); // result = 8
```
函数调用的执行过程有如下三步:
1. 参数传递: 将**实际参数**(调用时使用的参数)传递给**形式参数**(`参数列表`里的参数).
2. 执行函数体: 执行函数体中的代码.
3. 返回结果: 函数执行完毕后,返回结果(如果有).

每次调用函数时,系统会在**栈**上为该函数分配一个内存区域,用于存储函数的**参数**和**局部变量**.函数调用结束后,这块内存区域就会被释放.

# 参数传递
## 参数传递的类型
按值传递是指将实际参数的值复制给形参.形参的任何修改都不会影响实际参数.
```cpp
void f(int x) {x = 10;}

int main() {
	int a = 5;
	f(a); // a的值不会改变
	return 0;
}
```
按指针传递是指将实际参数的地址传递给形参.通过指针可以修改实际参数.
```cpp
void f(int *x) {*x = 10;}

int main() {
	int a = 5;
	f(&a); // 传递a的地址,a的值会改变
	return 0;
}
```
按引用传递是指将实际参数的引用传递给形参.形参的任何修改都会影响实际参数.
```cpp
void f(int &x) {x = 10;}

int main() {
	int a = 5;
	f(a); // 传递a的引用,a的值会改变
	return 0;
}
```
常量引用参数可以防止函数修改传入的参数,有助于提高效率和避免不必要的复制.
```cpp
void f(const int &x) {}
```


## 默认参数
默认参数是指在函数声明中为参数提供默认值,如果调用函数时没有提供相应的参数,将使用默认值.默认参数必须**从右往左**依次指定,因为实参传递给形参的过程是从左往右的.
```cpp
void write(string a, string b = "world!") {cout << a << ' ' << b << endl;}

int main() {
	write("Hello"); // Hello world!
	return 0;
}
```

## 可变参数
### 实现方法
参见[C++实现可变参数的三个方法](https://www.cnblogs.com/ofnoname/p/16524932.html).
C++11引入了`std::initializer_list`和**变长模板**来实现可变参数.
```cpp
#include <initializer_list>

int imin(std::initializer_list<int> li) {
	int im = *li.begin();
	for (auto x : li) if (x < im) im = x;
	return im;
}

int main() {
	std::cout << imin({1, 2, 3}) << std::endl;
}
```
`std::initializer_list`的缺点有: 只支持单一类型; **只能读**,不能写; 要额外加括号,形式不统一.

也可以使用可变参数模板:
```cpp
template<class T, class... Args> // Args为模板参数包
void foo(const T &t, const Args&... test); // test为函数参数包

foo(i, s, 42, d); // 包中有三个参数
foo(s, 42, "hi"); // 包中有两个参数
foo(d, s); // 包中有一个参数
foo("hi"); // 空包
```

### 函数参数包的展开
参见[c++11之函数参数包展开_博客园](https://www.cnblogs.com/pandamohist/p/13856489.html)和[包_zh.cppreference.com](https://zh.cppreference.com/w/cpp/language/pack).

1. 查询参数包的个数:
```cpp
template<typename... Args>
unsigned int length(Args... args) {
	return sizeof... (args);
}
```

2. 递归展开(根据执行过程可知,终止递归的函数还可以改为一个参数的函数来提高性能):
```cpp
// 1.递归终止函数
template <typename T>
T sum() {return 0;}
// 2.递归函数
template <typename T, typename ... Args>
T sum(const T& head, const Args... args) { // 此处Args...为展开函数参数包
	return head + sum<T>(args...); // 此处args...为展开
}
```

3. 逗号表达式展开:
```cpp
// 1.用作输出每个参数
template<typename T>
void show_arg(const T& t) {std::cout << t <<std::endl;}
// 2.用作展开参数包
template <typename ... Args>
void expand(const Args&... args) {
	int arr[] = {(show_arg(args), 0)...};
}
```
假设参数包`args`包含三个参数分别为`arg_1`,`arg_2`,`arg_3`.那么展开后得到`{(show_arg(arg_1), 0), (show_arg(arg_2), 0), (show_arg(arg_3), 0)}`,根据`,`运算符的运算法则,原代码相当于定义了一个`int`数组,数组有$4$个元素,值都为`0`.

4. 使用`lambda` + `,`表达式展开参数包(略).
5. 折叠表达式(C++17):

参见[C++17 折叠表达式_知乎](https://zhuanlan.zhihu.com/p/731232067)

| 类型 | 表达式 | 展开 |
| --- | --- | --- |
| 一元左折叠 | `(... op args)`| `(((arg1 op arg2) op arg3) ... op argn)`|
| 一元右折叠 | `(args op ...)`| `(arg1 ... op (arg[n-2] op (arg[n-1] op argn)))`|
| 二元左折叠 | `(init op ... op args)`| `(((init op arg1) op arg2) ... op argn)`|
| 二元右折叠 | `(args op ... op init)`| `(arg1 op ...(arg[n-1] op (argn op init)))`|

`op`代表运算符,如`+`,`,`,`=`,`&&`等等.`args`代表参数包(含有未展开的元素且优先级不得低于转型表达式 **什么意思?**).`init`代表初始值(不含未展开的参数包).
注意**圆括号**`()`也是折叠表达式的一部分.
```cpp
template <typename... Args>
T sum(Args... args) {
	return (0 + ... + args); // 防止无参调用sum()时报错
}
```
```cpp
void print(Args&&... args) {
	((cout << args << ' '), ...); // 将第一部分整体看作一个表达式
}
```
```cpp
```cpp
typedef long long ll;
template <typename T = ll>
T read() {
	bool b = 1; T v = 0; char c = getchar();
	for (; !isdigit(c); c = getchar()) if(c == '-') b = 0;
	for (; isdigit(c); c = getchar()) v = v * 10 + (c ^ '0');
	return b ? v : -v;
}
template <typename T, typename... Args>
T read(T &x, Args&... li) {
	x = read<T>();
	(..., (li = read<remove_reference_t<decltype(li)>>())); // 去除引用属性
	// if(sizeof... (li)) read(li...);
	return x;
}

int main() {
	int x, y, z, a, b;
	read(x, y, z);
	read(a);
	b = read();
}
```

# 返回值
## 普通返回值
函数可以返回一个值(类型在定义时声明).返回多值时可以使用`struct`或`tuple`.

## 返回引用
函数可以返回引用,允许调用者修改返回的变量.
```cpp
int &get_max(int &a, int &b) {
	return a > b ? a : b;
}

int main() {
	int x = 10, y = 20;
	get_max(x, y) = 30;
	cout << x << " " << y << endl; // x = 10, y = 20
}
```

## 返回指针
函数可以返回指针,但需要注意**指针有效性**.
```cpp
int *create_array(int size) {
	int *arr = new int[size];
	for (int i = 0; i < size; i++) {arr[i] = i;}
	return arr;
}

int main() {
	int *arr = create_array(5);
	for (int i = 0; i < 5; i++) cout << arr[i] << endl;
	delete[] arr;
	return 0;
}
```

# 函数重载
函数重载是指在同一个作用域中定义多个同名函数,但**参数列表不同**.编译器会自动选择合适的函数.函数重载需要满足如下规则:
1. 编译器根据参数列表选择合适的函数.
2. **返回类型不同不能**作为重载的依据.
3. 参数的常量性和引用性可以作为重载的依据.

# 内联函数
内联函数是一种优化手段,编译器会在调用点直接插入函数体,避免函数调用的开销.要求函数体短小,调用频繁.
```cpp
inline int add(int a, int b) {
	return a + b;
}
```

# 递归函数
## 基本概念 (略)
## 尾递归
如果递归调用是函数的最后一个操作,编译器可以优化为循环,避免栈溢出.
```cpp
int fib(int n) {
	if (n <= 1) return n; // 终止条件防止无限递归
	return fib(n - 1) + fib(n - 2);
}
```

# 函数指针
参考[C++函数指针_CSDN](https://blog.csdn.net/linxiaosongxxdddgs/article/details/122640563).
## 使用函数指针
函数指针是指向函数的指针,可以用来调用函数.函数指针也有数组的形式.
```cpp
int add(int a, int b) {return a + b;}
int sub(int a, int b) {return a - b;}
int mul(int a, int b) {return a * b;}

int main() {
	int (*func)(int, int) = mul;
	int (*f[2])(int, int) = {add, sub};
	int x = func(3, 5), y = f[0](3, 5), z = f[1](3, 5);
}
```
当我们把函数名作为一个值使用时,该函数自动地转换成指针(函数的地址).
```cpp
int add(int a, int b) {return a + b;}
int (*f)(int, int) = add, (*g)(int, int) = &add; // 取址符&可选
```
我们还能直接使用指向函数的指针调用该函数,无须提前解引用指针.
```cpp
cout << (*f)(1, 2) << g(3, 5) << endl;
```
## 函数指针形参
函数的形参可以是指向函数的指针,直接把函数作为实参使用时会**自动转换成指针**.
```cpp
int getLen(const string &s) {return s.size();}
int op1(const string &s, int op(const string&)); // 隐式转换
int op2(const string &s, int (*op)(const string&)); // 显式声明

op1("Hello", getLen); // 会自动转换为指针
op2("Hello", &getLen);
```
```cpp
typedef int (*F)(int, int);
int add(int a, int b) {return a + b;}
int sub(int a, int b) {return a - b;}
F func1 = add, func2 = sub;
F func() {return func1;}
int (*Func(int opt))(int, int) {return opt == 1 ? func1 : func2;}

int main() {
	cout << (*func())(3, 8) << " " << (*Func(2))(3, 8) << endl;
}
```
## typedef与函数指针 (待完成)
函数指针可以通过`typedef`简化:
```cpp
typedef int (*F)(int, int);
F func1 = add;
cout << (*func1)(5, 10) << endl;
```

## 返回函数指针
C++中虽然不能返回一个函数,但是能返回指向函数类型的指针.必须**显式地**把返回类型写成指针形式,编译器不会自动转换.声明返回函数指针的函数的三种方法:
1. 使用类型别名:

```cpp
using F = void(int, string); // F的类型为函数
using PF = void (*)(int, string); // PF的类型为函数指针,等价于F *

void g(int x, string s) {cout << x << " " << s << endl;}
PF f() {return g;}

int main() {
	string s1 = "good";
	F *pp = f();
	(*pp)(1, s1);
	f()(2, s1);
}
```
2. 直接声明:
按照由内向外的顺序阅读这条声明语句: 我们看到`f1`有形参列表,所以`f1`是个函数;`f1`前面有`*`,所以`f1`返回一个指针;进一步观察发现,指针的类型本身也包含形参列表,因此指针指向一个返回类型是`int`的函数.

```cpp
int (*f1(int))(int, int);
```
3. 使用尾置类型推导:

尾置返回类型跟在形参列表后面并以一个`->`符号开头.函数真正的返回类型跟在形参列表之后,我们在本应该出现返回类型的地方放置一个`auto`.
```cpp
auto f1(int x) -> int (*)(int, int) {}
```

## decltype与函数指针
当我们将`decltype`作用于某个函数时,它返回**函数类型**而非指针类型.因此,我们显式地加上`*`以表明我们需要返回指针,而非函数本身.
```cpp
int sumLen(const string& s1, const string& s2) {return s1.size() + s2.size();}
decltype(sumLen) *f = sumLen;
```

# lambda函数
参见[C++ lambda_cnblogs](https://www.cnblogs.com/keye/p/18399680").
## 基本语法
`lambda`函数是一种**匿名函数**,可以在需要函数的地方直接定义和使用.表达式的结构如下:
```cpp
[捕获列表](参数列表) -> 返回类型 {
    函数体;
};
```
1. 捕获列表: 用于指定`lambda`表达式可以使用的外部变量.
2. 参数列表: 和普通函数类似,定义`lambda`表达式的参数.
3. 返回类型(可选): 如果可以自动推导则可以省略.
4. 函数体: 定义`lambda`表达式的逻辑.

```cpp
int main() {
	auto add = [](int a, int b) -> int {
		return a + b;
	};
	cout << add(3, 5) << endl;
}
```

## 捕获方式
1. 按值捕获`[x]`: 将外部变量`x`按值传递给`lambda`表达式,修改时不会影响外部变量.
2. 按引用捕获`[&x]`: 将外部变量`x`的引用传递给`lambda`表达式，修改时会影响外部变量.
3. 捕获所有局部变量的副本`[=]`: 自动捕获所有外部局部变量的副本.
4. 捕获所有变量的引用`[&]`: 自动捕获所有外部局部变量的引用.
5. 混合捕获`[=, &x]`,`[&, x]`): 混合使用捕获方式,某些变量按值捕获,另一些按引用捕获.
6. 包捕获`[x...]`: 以包展开方式复制捕获参数包变量,等等...

## 可变性 (`mutable`)
默认情况下,`lambda`表达式按值捕获的变量是不可修改的.如果需要修改捕获的变量,可以使用`mutable`关键字:
```cpp
int x = 10;
auto f = [=](int a) mutable -> int {
	++x; // 对只读变量进行修改
	return x + a;
};
cout << f(5) << endl; // 输出16
```

## lambda函数作为形参
函数指针只能指向一个已存在的全局函数,并且带有捕获列表的`lambda`函数无法经类型转换变成函数指针.我们通过如下方式传递`lambda`表达式作为函数参数:

1. 使用`std::function`: `std::function()`是C++标准库中的一个通用多态函数包装器, 它可以存储,复制和调用任意可调用目标(函数,`lambda`表达式,绑定表达式或其他函数对象).其基本语法如下:

```cpp
std::function<返回类型(参数类型1, 参数类型2, ...)> func;
```
```cpp
void g(int a, int b, std::function<int(int, int)> func) {
	cout << func(a, b) << endl;
}

int main() {
	auto f = [](int a, int b) {return a + b;};
	g(3, 5, f);
	return 0;
}
```

2. 使用模板参数实现`template`.

# 